<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>School Clash Royale</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 1200px;
            padding: 10px;
        }

        #mainMenu {
            background: #2a2a2a;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
        }

        #mainMenu h1 {
            color: #ff0000;
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px #000;
        }

        .menu-btn {
            background: #ff0000;
            color: white;
            border: none;
            padding: 15px 40px;
            margin: 10px;
            font-size: 1.2em;
            cursor: pointer;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
        }

        .menu-btn:hover {
            background: #cc0000;
            transform: scale(1.05);
        }

        #deckBuilder {
            display: none;
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            width: 100%;
            max-width: 1000px;
        }

        .deck-section {
            margin-bottom: 20px;
        }

        .deck-section h3 {
            color: #ff0000;
            margin-bottom: 10px;
        }

        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .card-item {
            background: #3a3a3a;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
            text-align: center;
        }

        .card-item:hover {
            background: #4a4a4a;
            transform: translateY(-5px);
        }

        .card-item.selected {
            border-color: #00ff00;
            background: #2a4a2a;
        }

        .card-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .card-name {
            color: #fff;
            font-size: 0.9em;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .card-cost {
            color: #ffaa00;
            font-size: 0.8em;
        }

        .card-type {
            color: #aaa;
            font-size: 0.7em;
        }

        #selectedDeck {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }

        #gameCanvas {
            display: none;
            border: 3px solid #ff0000;
            border-radius: 5px;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            background: #f0f0f0;
        }

        #gameUI {
            display: none;
            width: 100%;
            max-width: 800px;
            margin-top: 10px;
        }

        #handCards {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .hand-card {
            background: #3a3a3a;
            padding: 8px;
            border-radius: 5px;
            cursor: pointer;
            border: 2px solid #555;
            min-width: 80px;
            text-align: center;
            transition: all 0.3s;
        }

        .hand-card:hover {
            transform: translateY(-5px);
            border-color: #ffaa00;
        }

        .hand-card.selected-hand {
            border-color: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }

        .hand-card.cant-afford {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #gameStats {
            display: flex;
            justify-content: space-between;
            color: white;
            padding: 10px;
            background: #2a2a2a;
            border-radius: 5px;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .dudu-bar {
            width: 100px;
            height: 20px;
            background: #1a1a1a;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #ffaa00;
        }

        .dudu-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffaa00, #ff6600);
            transition: width 0.3s;
        }

        .back-btn {
            background: #666;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 10px;
            cursor: pointer;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }

        .back-btn:hover {
            background: #888;
        }

        #gameOver {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
            z-index: 1000;
        }

        #gameOver h2 {
            color: #ff0000;
            font-size: 2.5em;
            margin-bottom: 20px;
        }

        .winner {
            color: #00ff00 !important;
        }

        @media (max-width: 768px) {
            #gameCanvas {
                max-width: 100%;
                height: auto;
            }

            .cards-grid {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            }

            #handCards {
                gap: 5px;
            }

            .hand-card {
                min-width: 60px;
                padding: 5px;
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Main Menu -->
        <div id="mainMenu">
            <h1>üè´ SCHOOL CLASH üè´</h1>
            <button class="menu-btn" onclick="startDeckBuilder(1)">1 Player Mode</button>
            <button class="menu-btn" onclick="startDeckBuilder(2)">2 Player Local</button>
        </div>

        <!-- Deck Builder -->
        <div id="deckBuilder">
            <h2 style="color: #ff0000; text-align: center; margin-bottom: 20px;">Build Your Deck</h2>
            <div id="deckBuilderContent"></div>
            <div id="selectedDeck">
                <h3 style="color: #00ff00;">Selected Cards: <span id="deckCount">0/10</span></h3>
                <div id="selectedCards" style="color: white; margin-top: 10px;"></div>
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="menu-btn" onclick="startGame()">Start Battle!</button>
                <button class="back-btn" onclick="backToMenu()">Back</button>
            </div>
        </div>

        <!-- Game Canvas -->
        <canvas id="gameCanvas" width="800" height="1000"></canvas>

        <!-- Game UI -->
        <div id="gameUI">
            <div id="gameStats">
                <div class="stat-item">
                    <span>Dudu:</span>
                    <div class="dudu-bar">
                        <div class="dudu-fill" id="duduFill" style="width: 100%;"></div>
                    </div>
                    <span id="duduCount">15/15</span>
                </div>
                <div class="stat-item">
                    <span>9B HP: <span id="player1HP">100</span></span>
                </div>
                <div class="stat-item">
                    <span>9A HP: <span id="player2HP">100</span></span>
                </div>
            </div>
            <div id="handCards"></div>
            <button class="back-btn" onclick="endGame()">End Game</button>
        </div>

        <!-- Game Over Screen -->
        <div id="gameOver">
            <h2 id="gameOverText">Game Over!</h2>
            <p id="winnerText" style="color: white; font-size: 1.5em; margin: 20px 0;"></p>
            <button class="menu-btn" onclick="backToMenu()">Main Menu</button>
        </div>
    </div>

    <script>
        // Game State
        let gameMode = 1; // 1 = single player, 2 = two player
        let selectedDeck = {
            characters: [],
            buildings: [],
            potions: []
        };

        // Card Definitions
        const CARDS = {
            characters: [
                { name: "Neil - The Brute", cost: 4, hp: 150, speed: 40, attack: 30, deathAttack: 50, type: "ground", ability: "shield-sword" },
                { name: "Uday - The Snipe", cost: 2, hp: 120, speed: 20, attack: 20, deathAttack: 15, type: "ground-range", ability: "sniper" },
                { name: "Chahak - The Bomb", cost: 2, hp: 80, speed: 15, attack: 15, type: "ground-explosive", ability: "bomber" },
                { name: "Naysha - The Shadow", cost: 2, hp: 50, speed: 45, attack: 10, poisonDmg: 5, type: "ground-assassin", ability: "poison-run" },
                { name: "Shubhan - The Boulder", cost: 4, hp: 999, speed: 30, attack: 40, type: "ground", ability: "unstoppable" },
                { name: "Aayansh - The Giant", cost: 4, hp: 80, speed: 30, attackMagic: 30, attackMelee: 35, type: "ground", ability: "magic-buff" },
                { name: "Adya - The Furnace", cost: 3, hp: 60, speed: 25, attack: 30, type: "air", ability: "hot-air-balloon" },
                { name: "Noel - The Summoner", cost: 3, hp: 60, speed: 25, attack: 25, type: "air-mage", ability: "summon-pathak" },
                { name: "Rishet - The Heist", cost: 5, hp: 1, speed: 25, type: "underground", ability: "steal-dudu", uses: 2 },
                { name: "Advik - The Flash", cost: 3, hp: 110, speed: 30, type: "underground-shield", ability: "bridge-block" }
            ],
            buildings: [
                { name: "Catapult", cost: 4, hp: 100, type: "offence", attack: 50, attackSpeed: 20 },
                { name: "Iron Wall", cost: 4, hp: 150, type: "defence", duration: 30 },
                { name: "Peekaboo-Shubhan", cost: 5, hp: 40, type: "hybrid", ability: "fake-wall" },
                { name: "Duus", cost: 3, hp: 70, type: "production", ability: "fast-dudu" },
                { name: "Mage Tower", cost: 4, hp: 70, type: "buff", ability: "troop-buff" }
            ],
            potions: [
                { name: "Frost", cost: 2, cooldown: 30, ability: "freeze" },
                { name: "Burn", cost: 3, cooldown: 45, ability: "damage-over-time" },
                { name: "Heal", cost: 2, cooldown: 30, ability: "heal-troops" },
                { name: "Buff", cost: 3, cooldown: 45, ability: "boost-stats" },
                { name: "Nerf", cost: 3, cooldown: 45, ability: "reduce-stats" }
            ]
        };

        // Game Variables
        let canvas, ctx;
        let duduCount = 15;
        let maxDudu = 15;
        let duduTimer = 0;
        let duduRate = 3000; // 3 seconds
        let gameRunning = false;
        let selectedCardInHand = null;
        let hand = [];
        let deck = [];

        // Troops and Buildings
        let troops = [];
        let buildings = [];
        let projectiles = [];

        // Tower HP
        let player1TowerHP = 100;
        let player2TowerHP = 100;

        // AI Variables
        let aiDudu = 15;
        let aiTroops = [];
        let aiBuildings = [];
        let aiHand = [];
        let aiDeck = [];
        let aiTimer = 0;

        // Game objects
        class Troop {
            constructor(card, x, y, player, lane) {
                this.card = card;
                this.x = x;
                this.y = y;
                this.player = player;
                this.lane = lane;
                this.hp = card.hp;
                this.maxHp = card.hp;
                this.speed = card.speed;
                this.attack = card.attack || card.attackMagic || 0;
                this.alive = true;
                this.attackTimer = 0;
                this.attackCooldown = 1000;
                this.moveTimer = 0;
                this.target = null;
                this.buffMultiplier = 1;
                this.poisoned = false;
                this.poisonTimer = 0;
                this.frozen = false;
                this.frozenTimer = 0;
                this.summonTimer = 0;
                this.summonCooldown = 45000;
                this.minionsSpawned = 0;
                this.underground = card.type.includes('underground');
                this.surfaced = false;
                this.usesLeft = card.uses || 999;
            }

            update(deltaTime) {
                if (!this.alive || this.frozen) {
                    if (this.frozen) {
                        this.frozenTimer -= deltaTime;
                        if (this.frozenTimer <= 0) this.frozen = false;
                    }
                    return;
                }

                // Poison damage
                if (this.poisoned) {
                    this.poisonTimer -= deltaTime;
                    if (this.poisonTimer <= 0) {
                        this.poisoned = false;
                    } else if (Math.random() < 0.01) {
                        this.hp -= 3;
                        if (this.hp <= 0) this.die();
                    }
                }

                // Underground movement
                if (this.underground && !this.surfaced) {
                    this.moveTimer += deltaTime;
                    if (this.moveTimer >= 50) {
                        this.y += this.player === 1 ? 2 : -2;
                        this.moveTimer = 0;
                        
                        // Surface at bridge (middle of arena)
                        if ((this.player === 1 && this.y >= 450) || (this.player === 2 && this.y <= 550)) {
                            this.surfaced = true;
                        }
                    }
                    return;
                }

                // Summoner ability - spawn Pathaks
                if (this.card.ability === 'summon-pathak') {
                    this.summonTimer += deltaTime;
                    if (this.summonTimer >= this.summonCooldown && this.minionsSpawned < 3) {
                        this.spawnPathak();
                        this.summonTimer = 0;
                        this.minionsSpawned++;
                    }
                }

                // Find target
                this.findTarget();

                // Movement
                if (!this.target || (this.card.type.includes('range') && this.getDistance(this.target) > 50)) {
                    this.move(deltaTime);
                }

                // Attack
                if (this.target) {
                    this.attackTimer += deltaTime;
                    if (this.attackTimer >= this.attackCooldown) {
                        this.attackTarget();
                        this.attackTimer = 0;
                    }
                }
            }

            findTarget() {
                const enemies = this.player === 1 ? (gameMode === 1 ? aiTroops : troops.filter(t => t.player === 2)) : troops.filter(t => t.player === 1);
                const enemyBuildings = this.player === 1 ? (gameMode === 1 ? aiBuildings : buildings.filter(b => b.player === 2)) : buildings.filter(b => b.player === 1);

                let closest = null;
                let minDist = Infinity;

                // Check troops
                for (let enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = this.getDistance(enemy);
                    if (dist < minDist && dist < 200) {
                        minDist = dist;
                        closest = enemy;
                    }
                }

                // Check buildings
                for (let building of enemyBuildings) {
                    if (!building.alive) continue;
                    const dist = this.getDistance(building);
                    if (dist < minDist && dist < 200) {
                        minDist = dist;
                        closest = building;
                    }
                }

                this.target = closest;
            }

            getDistance(other) {
                return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
            }

            move(deltaTime) {
                this.moveTimer += deltaTime;
                const moveSpeed = 50 / this.speed;
                
                if (this.moveTimer >= moveSpeed) {
                    // Move toward enemy tower
                    if (this.player === 1) {
                        this.y -= 2;
                        if (this.y < 50) this.y = 50;
                    } else {
                        this.y += 2;
                        if (this.y > 950) this.y = 950;
                    }
                    this.moveTimer = 0;
                }
            }

            attackTarget() {
                if (!this.target || !this.target.alive) {
                    this.target = null;
                    return;
                }

                let damage = this.attack * this.buffMultiplier;

                // Special abilities
                if (this.card.ability === 'unstoppable') {
                    damage = 40;
                }

                this.target.hp -= damage;
                if (this.target.hp <= 0) {
                    this.target.die();
                }
            }

            spawnPathak() {
                const pathak = {
                    hp: 1,
                    maxHp: 1,
                    attack: 15,
                    x: this.x + (Math.random() - 0.5) * 20,
                    y: this.y,
                    player: this.player,
                    lane: this.lane,
                    alive: true,
                    card: { name: 'Pathak', type: 'air' },
                    speed: 35,
                    attackTimer: 0,
                    attackCooldown: 800,
                    moveTimer: 0,
                    target: null,
                    buffMultiplier: 1,
                    findTarget: this.findTarget,
                    getDistance: this.getDistance,
                    move: this.move,
                    attackTarget: this.attackTarget,
                    die: this.die,
                    update: this.update
                };
                
                troops.push(pathak);
            }

            die() {
                this.alive = false;

                // Death abilities
                if (this.card.ability === 'shield-sword') {
                    // Throw sword at highest HP ground troop
                    const enemies = this.player === 1 ? troops.filter(t => t.player === 2 && !t.card.type.includes('air')) : 
                                                        troops.filter(t => t.player === 1 && !t.card.type.includes('air'));
                    let target = null;
                    let maxHp = 0;
                    for (let enemy of enemies) {
                        if (enemy.alive && enemy.hp > maxHp) {
                            maxHp = enemy.hp;
                            target = enemy;
                        }
                    }
                    if (target) {
                        target.hp -= 50;
                        if (target.hp <= 0) target.die();
                    }
                }

                if (this.card.ability === 'sniper') {
                    // Damage all troops in lane
                    const enemies = this.player === 1 ? troops.filter(t => t.player === 2) : troops.filter(t => t.player === 1);
                    for (let enemy of enemies) {
                        if (enemy.alive && Math.abs(enemy.x - this.x) < 100) {
                            enemy.hp -= 15;
                            if (enemy.hp <= 0) enemy.die();
                        }
                    }
                    // Damage tower
                    if (this.player === 1) {
                        player2TowerHP -= 20;
                    } else {
                        player1TowerHP -= 20;
                    }
                }

                if (this.card.ability === 'bomber') {
                    // Explosion - damage all in range
                    const allTroops = [...troops];
                    for (let troop of allTroops) {
                        if (troop !== this && this.getDistance(troop) < 100) {
                            troop.hp -= 40;
                            if (troop.hp <= 0) troop.die();
                        }
                    }
                    // Damage own troops 40%
                    const friendlies = troops.filter(t => t.player === this.player && t !== this);
                    for (let friendly of friendlies) {
                        if (this.getDistance(friendly) < 100) {
                            friendly.hp -= friendly.maxHp * 0.4;
                            if (friendly.hp <= 0) friendly.die();
                        }
                    }
                }

                if (this.card.ability === 'poison-run') {
                    // Create poison ground
                    // Mark area as poisoned (simplified - just poison nearby enemies)
                    const enemies = this.player === 1 ? troops.filter(t => t.player === 2) : troops.filter(t => t.player === 1);
                    for (let enemy of enemies) {
                        if (enemy.alive && this.getDistance(enemy) < 80) {
                            enemy.poisoned = true;
                            enemy.poisonTimer = 5000;
                        }
                    }
                }

                if (this.card.ability === 'magic-buff') {
                    // Buff all friendly troops
                    const friendlies = troops.filter(t => t.player === this.player && t.alive);
                    for (let friendly of friendlies) {
                        friendly.buffMultiplier = 1.5;
                        friendly.hp += friendly.maxHp * 0.5;
                        setTimeout(() => {
                            if (friendly.alive) friendly.buffMultiplier = 1;
                        }, 10000);
                    }
                }

                if (this.card.ability === 'hot-air-balloon') {
                    // Create coal barrier (simplified - slow enemies)
                    const enemies = this.player === 1 ? troops.filter(t => t.player === 2 && !t.card.type.includes('air')) : 
                                                        troops.filter(t => t.player === 1 && !t.card.type.includes('air'));
                    for (let enemy of enemies) {
                        if (enemy.alive && this.getDistance(enemy) < 100) {
                            enemy.speed *= 0.5;
                            setTimeout(() => {
                                if (enemy.alive) enemy.speed *= 2;
                            }, 5000);
                        }
                    }
                }

                if (this.card.ability === 'summon-pathak') {
                    // Nerf all enemy troops
                    const enemies = this.player === 1 ? troops.filter(t => t.player === 2) : troops.filter(t => t.player === 1);
                    for (let enemy of enemies) {
                        if (enemy.alive) {
                            enemy.speed *= 0.7;
                            enemy.attack *= 0.7;
                            setTimeout(() => {
                                if (enemy.alive) {
                                    enemy.speed /= 0.7;
                                    enemy.attack /= 0.7;
                                }
                            }, 10000);
                        }
                    }
                }
            }

            draw() {
                if (!this.alive) return;

                // Draw troop as pixel sprite
                ctx.fillStyle = this.player === 1 ? '#3366ff' : '#ff3333';
                
                // Different shapes for different types
                if (this.card.type.includes('air')) {
                    // Triangle for air troops
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y - 10);
                    ctx.lineTo(this.x - 8, this.y + 10);
                    ctx.lineTo(this.x + 8, this.y + 10);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.card.ability === 'unstoppable') {
                    // Circle for boulder
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 12, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.underground && !this.surfaced) {
                    // Small dot for underground
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Rectangle for ground troops
                    ctx.fillRect(this.x - 8, this.y - 8, 16, 16);
                }

                // HP bar
                if (this.hp < this.maxHp && this.hp > 0) {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x - 10, this.y - 18, 20, 3);
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(this.x - 10, this.y - 18, 20 * (this.hp / this.maxHp), 3);
                }

                // Status effects
                if (this.frozen) {
                    ctx.fillStyle = '#00ffff';
                    ctx.font = '12px Arial';
                    ctx.fillText('‚ùÑ', this.x - 6, this.y - 20);
                }
                if (this.poisoned) {
                    ctx.fillStyle = '#00ff00';
                    ctx.font = '12px Arial';
                    ctx.fillText('‚ò†', this.x + 6, this.y - 20);
                }
            }
        }

        class Building {
            constructor(card, x, y, player) {
                this.card = card;
                this.x = x;
                this.y = y;
                this.player = player;
                this.hp = card.hp;
                this.maxHp = card.hp;
                this.alive = true;
                this.attackTimer = 0;
                this.durationTimer = 0;
                this.target = null;
            }

            update(deltaTime) {
                if (!this.alive) return;

                // Duration-based buildings
                if (this.card.duration) {
                    this.durationTimer += deltaTime;
                    if (this.durationTimer >= this.card.duration * 1000) {
                        this.die();
                        return;
                    }
                }

                // Offensive buildings
                if (this.card.type === 'offence') {
                    this.attackTimer += deltaTime;
                    if (this.attackTimer >= this.card.attackSpeed * 1000) {
                        this.attackTower();
                        this.attackTimer = 0;
                    }
                }
            }

            attackTower() {
                if (this.player === 1) {
                    player2TowerHP -= this.card.attack;
                } else {
                    player1TowerHP -= this.card.attack;
                }
            }

            die() {
                this.alive = false;

                // Peekaboo releases Shubhan
                if (this.card.ability === 'fake-wall') {
                    const shubhanCard = { ...CARDS.characters[4], attack: 20 }; // Half damage
                    const boulder = new Troop(shubhanCard, this.x, this.y, this.player, Math.floor(Math.random() * 3));
                    troops.push(boulder);
                }
            }

            draw() {
                if (!this.alive) return;

                ctx.fillStyle = this.player === 1 ? '#4488ff' : '#ff4444';
                ctx.fillRect(this.x - 15, this.y - 15, 30, 30);

                // Symbol
                ctx.fillStyle = '#fff';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                const symbols = { offence: '‚öî', defence: 'üõ°', hybrid: 'üé≠', production: 'üíé', buff: '‚≠ê' };
                ctx.fillText(symbols[this.card.type] || 'üè¢', this.x, this.y + 5);

                // HP bar
                if (this.hp < this.maxHp) {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x - 15, this.y - 25, 30, 3);
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(this.x - 15, this.y - 25, 30 * (this.hp / this.maxHp), 3);
                }
            }
        }

        // Deck Builder Functions
        function startDeckBuilder(mode) {
            gameMode = mode;
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('deckBuilder').style.display = 'block';
            
            selectedDeck = { characters: [], buildings: [], potions: [] };
            renderDeckBuilder();
        }

        function renderDeckBuilder() {
            const content = document.getElementById('deckBuilderContent');
            content.innerHTML = '';

            // Character Cards
            content.innerHTML += '<div class="deck-section"><h3>Character Cards (Select 5)</h3><div class="cards-grid" id="characterGrid"></div></div>';
            
            // Building Cards
            content.innerHTML += '<div class="deck-section"><h3>Building/Trap Cards (Select 2)</h3><div class="cards-grid" id="buildingGrid"></div></div>';
            
            // Potion Cards
            content.innerHTML += '<div class="deck-section"><h3>Potion Cards (Select 3)</h3><div class="cards-grid" id="potionGrid"></div></div>';

            // Populate grids
            populateCardGrid('characterGrid', CARDS.characters, 'characters', 5);
            populateCardGrid('buildingGrid', CARDS.buildings, 'buildings', 2);
            populateCardGrid('potionGrid', CARDS.potions, 'potions', 3);

            updateDeckDisplay();
        }

        function populateCardGrid(gridId, cards, category, maxSelect) {
            const grid = document.getElementById(gridId);
            grid.innerHTML = '';

            cards.forEach((card, index) => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card-item';
                cardDiv.innerHTML = `
                    <div class="card-name">${card.name}</div>
                    <div class="card-cost">${card.cost} Dudu</div>
                    <div class="card-type">${card.type || card.ability}</div>
                `;
                
                cardDiv.onclick = () => toggleCardSelection(card, category, maxSelect, cardDiv);
                grid.appendChild(cardDiv);
            });
        }

        function toggleCardSelection(card, category, maxSelect, element) {
            const index = selectedDeck[category].findIndex(c => c.name === card.name);
            
            if (index > -1) {
                selectedDeck[category].splice(index, 1);
                element.classList.remove('selected');
            } else {
                if (selectedDeck[category].length < maxSelect) {
                    selectedDeck[category].push(card);
                    element.classList.add('selected');
                } else {
                    alert(`You can only select ${maxSelect} ${category} cards!`);
                }
            }
            
            updateDeckDisplay();
        }

        function updateDeckDisplay() {
            const total = selectedDeck.characters.length + selectedDeck.buildings.length + selectedDeck.potions.length;
            document.getElementById('deckCount').textContent = `${total}/10`;

            const selectedCards = document.getElementById('selectedCards');
            selectedCards.innerHTML = `
                <div>Characters: ${selectedDeck.characters.map(c => c.name).join(', ') || 'None'}</div>
                <div>Buildings: ${selectedDeck.buildings.map(c => c.name).join(', ') || 'None'}</div>
                <div>Potions: ${selectedDeck.potions.map(c => c.name).join(', ') || 'None'}</div>
            `;
        }

        function startGame() {
            const total = selectedDeck.characters.length + selectedDeck.buildings.length + selectedDeck.potions.length;
            if (total !== 10) {
                alert('Please select exactly 10 cards (5 characters, 2 buildings, 3 potions)!');
                return;
            }

            // Setup game
            document.getElementById('deckBuilder').style.display = 'none';
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('gameUI').style.display = 'block';

            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            // Initialize game
            initializeGame();
            gameLoop();
        }

        function initializeGame() {
            // Create deck from selected cards
            deck = [...selectedDeck.characters, ...selectedDeck.buildings, ...selectedDeck.potions];
            shuffleArray(deck);

            // Draw initial hand
            hand = [];
            for (let i = 0; i < 4; i++) {
                if (deck.length > 0) {
                    hand.push(deck.pop());
                }
            }

            // AI deck (random or copy player deck)
            if (gameMode === 1) {
                aiDeck = [...deck]; // Simple AI gets same cards
                shuffleArray(aiDeck);
                aiHand = [];
                for (let i = 0; i < 4; i++) {
                    if (aiDeck.length > 0) {
                        aiHand.push(aiDeck.pop());
                    }
                }
            }

            // Reset game state
            duduCount = 15;
            aiDudu = 15;
            player1TowerHP = 100;
            player2TowerHP = 100;
            troops = [];
            buildings = [];
            aiTroops = [];
            aiBuildings = [];
            gameRunning = true;

            renderHand();
            updateUI();
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function renderHand() {
            const handDiv = document.getElementById('handCards');
            handDiv.innerHTML = '';

            hand.forEach((card, index) => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'hand-card';
                if (card.cost > duduCount) cardDiv.classList.add('cant-afford');
                if (selectedCardInHand === index) cardDiv.classList.add('selected-hand');
                
                cardDiv.innerHTML = `
                    <div style="font-size: 0.9em; font-weight: bold; color: white;">${card.name.split('-')[0].trim()}</div>
                    <div style="color: #ffaa00; font-size: 0.8em;">${card.cost} üíé</div>
                `;
                
                cardDiv.onclick = () => selectCardFromHand(index);
                handDiv.appendChild(cardDiv);
            });
        }

        function selectCardFromHand(index) {
            if (hand[index].cost > duduCount) return;
            selectedCardInHand = index;
            renderHand();
        }

        // Canvas click handler
        canvas.addEventListener('click', (e) => {
            if (!gameRunning || selectedCardInHand === null) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Only allow placement in player's half
            if (y < 500 || y > 950) return;

            playCard(selectedCardInHand, x, y);
        });

        function playCard(handIndex, x, y) {
            const card = hand[handIndex];
            if (card.cost > duduCount) return;

            duduCount -= card.cost;

            // Determine lane (0, 1, 2)
            const lane = Math.floor(x / (canvas.width / 3));

            // Create troop or building
            if (CARDS.characters.includes(card)) {
                const troop = new Troop(card, x, y, 1, lane);
                troops.push(troop);

                // Special: Heist steals Dudu
                if (card.ability === 'steal-dudu' && troop.usesLeft > 0) {
                    const stolen = Math.floor(Math.random() * 2) + 2; // 2-3 Dudu
                    aiDudu = Math.max(0, aiDudu - stolen);
                    duduCount += stolen;
                    troop.usesLeft--;
                    troop.die(); // Disappears after use
                }
            } else if (CARDS.buildings.includes(card)) {
                const building = new Building(card, x, y, 1);
                buildings.push(building);

                // Special: Duus building speeds up production
                if (card.ability === 'fast-dudu') {
                    duduRate = 1500;
                }

                // Special: Mage Tower buffs troops
                if (card.ability === 'troop-buff') {
                    setInterval(() => {
                        if (building.alive) {
                            troops.filter(t => t.player === 1 && t.alive).forEach(t => {
                                t.buffMultiplier = 1.3;
                            });
                        }
                    }, 100);
                }
            } else if (CARDS.potions.includes(card)) {
                applyPotion(card, x, y, 1);
            }

            // Draw new card
            hand.splice(handIndex, 1);
            if (deck.length > 0) {
                hand.push(deck.pop());
            }

            selectedCardInHand = null;
            renderHand();
            updateUI();
        }

        function applyPotion(card, x, y, player) {
            const radius = 100;
            const targetTroops = troops.filter(t => {
                const dist = Math.sqrt((t.x - x) ** 2 + (t.y - y) ** 2);
                return dist < radius;
            });

            switch (card.ability) {
                case 'freeze':
                    targetTroops.forEach(t => {
                        if (t.player !== player) {
                            t.frozen = true;
                            t.frozenTimer = 3000;
                        }
                    });
                    break;
                case 'damage-over-time':
                    targetTroops.forEach(t => {
                        if (t.player !== player) {
                            t.poisoned = true;
                            t.poisonTimer = 5000;
                        }
                    });
                    break;
                case 'heal-troops':
                    targetTroops.forEach(t => {
                        if (t.player === player) {
                            t.hp = Math.min(t.maxHp, t.hp + 50);
                        }
                    });
                    break;
                case 'boost-stats':
                    targetTroops.forEach(t => {
                        if (t.player === player) {
                            t.buffMultiplier = 1.5;
                            setTimeout(() => { t.buffMultiplier = 1; }, 8000);
                        }
                    });
                    break;
                case 'reduce-stats':
                    targetTroops.forEach(t => {
                        if (t.player !== player) {
                            t.speed *= 0.7;
                            t.attack *= 0.7;
                            setTimeout(() => {
                                t.speed /= 0.7;
                                t.attack /= 0.7;
                            }, 8000);
                        }
                    });
                    break;
            }
        }

        // AI Logic
        function updateAI(deltaTime) {
            if (gameMode !== 1) return;

            aiTimer += deltaTime;
            
            // AI plays cards every 3-5 seconds if it can afford
            if (aiTimer >= 3000 + Math.random() * 2000) {
                aiTimer = 0;

                // Find affordable card
                const affordable = aiHand.filter(c => c.cost <= aiDudu);
                if (affordable.length > 0) {
                    const card = affordable[Math.floor(Math.random() * affordable.length)];
                    const handIndex = aiHand.indexOf(card);
                    
                    aiDudu -= card.cost;

                    // Random position in AI half
                    const x = Math.random() * canvas.width;
                    const y = 100 + Math.random() * 350;
                    const lane = Math.floor(x / (canvas.width / 3));

                    if (CARDS.characters.includes(card)) {
                        const troop = new Troop(card, x, y, 2, lane);
                        aiTroops.push(troop);
                    } else if (CARDS.buildings.includes(card)) {
                        const building = new Building(card, x, y, 2);
                        aiBuildings.push(building);
                    } else if (CARDS.potions.includes(card)) {
                        applyPotion(card, x, y, 2);
                    }

                    // Draw new card
                    aiHand.splice(handIndex, 1);
                    if (aiDeck.length > 0) {
                        aiHand.push(aiDeck.pop());
                    }
                }
            }

            // Update AI troops
            aiTroops.forEach(troop => {
                troop.update(deltaTime);
                
                // Attack player tower if in range
                if (troop.alive && troop.y > 900 && !troop.underground) {
                    player1TowerHP -= troop.attack * 0.1;
                    if (Math.random() < 0.01) troop.die();
                }
            });

            // Update AI buildings
            aiBuildings.forEach(building => building.update(deltaTime));

            // Clean up dead troops
            aiTroops = aiTroops.filter(t => t.alive);
            aiBuildings = aiBuildings.filter(b => b.alive);
        }

        // Game Loop
        let lastTime = Date.now();
        let duduAccumulator = 0;

        function gameLoop() {
            if (!gameRunning) return;

            const now = Date.now();
            const deltaTime = now - lastTime;
            lastTime = now;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw arena
            drawArena();

            // Update Dudu
            duduAccumulator += deltaTime;
            if (duduAccumulator >= duduRate) {
                duduCount = Math.min(maxDudu, duduCount + 1);
                if (gameMode === 1) aiDudu = Math.min(maxDudu, aiDudu + 1);
                duduAccumulator = 0;
            }

            // Update troops
            troops.forEach(troop => {
                troop.update(deltaTime);
                
                // Attack enemy tower if in range
                if (troop.alive && troop.y < 100 && !troop.underground) {
                    player2TowerHP -= troop.attack * 0.1;
                    if (Math.random() < 0.01) troop.die();
                }
            });

            // Update buildings
            buildings.forEach(building => building.update(deltaTime));

            // Update AI
            updateAI(deltaTime);

            // Draw everything
            buildings.forEach(b => b.draw());
            aiBuildings.forEach(b => b.draw());
            troops.forEach(t => t.draw());
            aiTroops.forEach(t => t.draw());

            // Draw towers
            drawTowers();

            // Clean up dead troops
            troops = troops.filter(t => t.alive);
            buildings = buildings.filter(b => b.alive);

            // Update UI
            updateUI();

            // Check win condition
            if (player2TowerHP <= 0) {
                endGameWithWinner(1);
                return;
            }
            if (player1TowerHP <= 0) {
                endGameWithWinner(2);
                return;
            }

            requestAnimationFrame(gameLoop);
        }

        function drawArena() {
            // Corridor floor - pale white with random red tiles
            for (let y = 0; y < canvas.height; y += 20) {
                for (let x = 0; x < canvas.width; x += 20) {
                    if (Math.random() < 0.1) {
                        ctx.fillStyle = '#ff0000';
                    } else {
                        ctx.fillStyle = '#f0f0f0';
                    }
                    ctx.fillRect(x, y, 20, 20);
                }
            }

            // Blood river in middle
            ctx.fillStyle = '#8B0000';
            ctx.fillRect(0, 480, canvas.width, 40);
            
            // Add flowing effect
            ctx.fillStyle = '#660000';
            const waveOffset = (Date.now() / 100) % 20;
            for (let i = 0; i < canvas.width; i += 20) {
                ctx.fillRect(i + waveOffset, 485, 10, 5);
                ctx.fillRect(i + waveOffset, 505, 10, 5);
            }
        }

        function drawTowers() {
            // Player 1 tower (9B)
            ctx.fillStyle = player1TowerHP > 50 ? '#3366ff' : '#ff6600';
            ctx.fillRect(canvas.width / 2 - 40, 920, 80, 60);
            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('9B', canvas.width / 2, 955);
            
            // HP bar
            ctx.fillStyle = '#333';
            ctx.fillRect(canvas.width / 2 - 40, 910, 80, 5);
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(canvas.width / 2 - 40, 910, 80 * (player1TowerHP / 100), 5);

            // Player 2 tower (9A)
            ctx.fillStyle = player2TowerHP > 50 ? '#ff3333' : '#ff6600';
            ctx.fillRect(canvas.width / 2 - 40, 20, 80, 60);
            ctx.fillStyle = '#fff';
            ctx.fillText('9A', canvas.width / 2, 55);
            
            // HP bar
            ctx.fillStyle = '#333';
            ctx.fillRect(canvas.width / 2 - 40, 85, 80, 5);
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(canvas.width / 2 - 40, 85, 80 * (player2TowerHP / 100), 5);
        }

        function updateUI() {
            document.getElementById('duduCount').textContent = `${duduCount}/${maxDudu}`;
            document.getElementById('duduFill').style.width = `${(duduCount / maxDudu) * 100}%`;
            document.getElementById('player1HP').textContent = Math.max(0, Math.floor(player1TowerHP));
            document.getElementById('player2HP').textContent = Math.max(0, Math.floor(player2TowerHP));
        }

        function endGameWithWinner(winner) {
            gameRunning = false;
            document.getElementById('gameOver').style.display = 'block';
            
            if (winner === 1) {
                document.getElementById('gameOverText').textContent = 'üéâ VICTORY! üéâ';
                document.getElementById('gameOverText').classList.add('winner');
                document.getElementById('winnerText').textContent = 'Class 9B Wins!';
            } else {
                document.getElementById('gameOverText').textContent = 'üíÄ DEFEAT üíÄ';
                document.getElementById('winnerText').textContent = 'Class 9A Wins!';
            }
        }

        function endGame() {
            gameRunning = false;
            backToMenu();
        }

        function backToMenu() {
            document.getElementById('gameCanvas').style.display = 'none';
            document.getElementById('gameUI').style.display = 'none';
            document.getElementById('deckBuilder').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'block';
            gameRunning = false;
        }

        // Responsive canvas
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const maxWidth = Math.min(800, window.innerWidth - 40);
            const scale = maxWidth / 800;
            
            canvas.style.width = maxWidth + 'px';
            canvas.style.height = (1000 * scale) + 'px';
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
    </script>
</body>
</html>
